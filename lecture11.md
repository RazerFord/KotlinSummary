### Каналы

- В первом приближении - аналог блокирующей очереди
- Нет класса `Channel`
- Есть интерфейсы `SendChannel<T>` и `ReceiveChannel<T>`
- Есть наследующий обоих интерфейс `Channel<T>`
- Есть `factory`-метод `Channel<T>` создающий нужную реализацию
- По умолчанию используется режим рандеву
- При посылке дожидаемся того, что будет читать
- Передаем из рук в руки
- Возможны варианты: конечный буфер, бесконечный буфер
- Поведение при записи в переполненный: suspend, перезапись старых, исключение
- Поведение при чтении из пустого : suspend, исключение


```kotlin
val channel = Channel<Int>()
fun main() = runBlocking(Dispatchers.Default) {
    launch {
        for (x in 1..5) {
            println("before send")
            channel.send(x * x) // заблокируется тут, пока не будет вызван receive
            println("after send") // выполнит и перейдет к следующей итерации, когда будет вызван receive
        }
    }
    repeat(5) {
        println(channel.receive()) // выполнит перед тем, как второй раз будет вызван `send`
        println("  got")
    }
}
```

Канал можно закрыть. На читающей стороне это приведет к завершению итератора. В блокирующих очередях подобное можно делать через отдельные приседания в пользовательском коде

```kotlin
fun main() = runBlocking {
    val channel = Channel<Int>()
    launch {
        for (x in 1..5) channel.send(x * x)
        channel.close()// без `close` итератор ниже не закончится
    }
    for (y in channel) println(y)
    println("Done!")
}
```

```kotlin
@OptIn(ExperimentalCoroutinesApi::class)
fun CoroutineScope.produceSquares(): ReceiveChannel<Int> =
    produce {
        println(coroutineContext.job) // другая Job
        for (x in 1..5) send(x * x)
    }
fun main() = runBlocking(Dispatchers.Default) {
    println(coroutineContext.job)
    val squares = produceSquares()
    squares.consumeEach { println(it) }
    println("Done!")
}
```

- В нашем случае `producer`-корутина порождает данные из себя
- И здесь рандеву - идеальная конфигурация
канала
- Но может быть так, что данные мы берем
откуда-то еще
- Из внешнего мира или от другого `producer`-а
- Не факт, что всегда можем спокойно ждать, пока `consumer` прочитает. Противоположная крайность - бесконечная очередь. Все сможем буферизовать. Одна беда - память конечна
- Промежуточный вариант - буфер конечного размера. В канале можно сохранить данные, порожденные от вспышек активности. В идеале, размер буфера должен быть расчитан на них. Но не должно быть принципиально дизбаланса скоростей записи и чтения
- Можем включить режим перезаписи старого. Например, это данные каких-то замеров. Старые не успели обработать - и уже новые подъехали. А если при заполнении ждем освобождения - это механизм `backpressure`

`livelock`
```kotlin
val p1: CoroutineScope.() -> ReceiveChannel<Int> =
    fun CoroutineScope.(): ReceiveChannel<Int> =
        produce {
            println(coroutineContext.job)
            val c2 = p2()
            c2.consumeEach {
                send(it)
            }
        }
val p2: CoroutineScope.() -> ReceiveChannel<Int> =
    fun CoroutineScope.(): ReceiveChannel<Int> =
        produce {
            println(coroutineContext.job)
            val c1 = p1()
            c1.consumeEach {
                send(it)
            }
        }

fun main() = runBlocking {
    p1().consumeEach {
        println("v: " + it)
    }
}
```

```kotlin
val p1: CoroutineScope.() -> ReceiveChannel<Int> =
    fun CoroutineScope.(): ReceiveChannel<Int> =
        produce {
            println(coroutineContext.job)
            c2Ref.get().consumeEach {  // рекурсивно вызовет себя же в результате заблокируется на `send`
                send(it)
            }
        }

val p2: CoroutineScope.() -> ReceiveChannel<Int> =
    fun CoroutineScope.(): ReceiveChannel<Int> =
        produce {
            println(coroutineContext.job)
            c1Ref.get().consumeEach { // рекурсивно вызовет себя же в результате заблокируется на `send`
                send(it)
            }
        }

val c1Ref: AtomicReference<ReceiveChannel<Int>> =
    AtomicReference(null)
val c2Ref: AtomicReference<ReceiveChannel<Int>> =
    AtomicReference(null)

fun main() = runBlocking {
    c1Ref.set(p1())
    c2Ref.set(p2())
    c2Ref.get().consumeEach {
        println(it)
    }
}
```

### Акторы

Внеязыковая абстракция. Легкий объект с состоянием и поведением. Может получать сообщения. Поведение - только как реакция на сообщения

Можем изменить состояние. Можем ответить отправителю. Можем послать сообщения кому-то другому. Все асинхронно, даже ответ отправителю

У каждого актора своя ось времени. На оси строго упорядочены отрезки обработки сообщений. Ненулевые, но и не большие. Не должны произвольно растягиваться. Разве что в рамках `trade-of`

Актор можно считать объектом. С полиморфизмом и наследованием - зависит от реализации. Инкапсуляция - близка к идеалу. Вместо методов - сообщения. Сложность - только с гарантией доставки ответа

Объект - как будто соответствует сущности
реального мира. Но в безнитевой модели исполнения - в любой момент времени активен один объект. Что не очень соответствует реальности. А в многонитевой - создается несколько временных осей

На каждой такой оси воспроизводится схема с одним активный в моменте объектом. Но на разных временных осях может активизироваться один и тот же объект. В однонитевой ситуации модель вынужденно упрощается. А в многонитевой - она "копируется" на несколько нитей

Акторная модель "правильнее" использует многопоточность. Акторы-объекты реально параллельны. И у них не двоится сознание. Можно проектировать систему как набор акторов. С состоянием и правилами коммуникации

#### Пример Краулинг

- Какие-то акторы непосредственно общаются с http-клиентом
- Какие-то - анализируют содержимое
- Какие-то сохраняют полезную информацию
- Какие-то - отслеживают очередь
- Какие-то - обрабатывают сбои и отказы

### Гарантии доставки

- `Exactly once` - ценой блокировок или усложненных алгоритмов
- At `most once` - бесплатно
- At `least once` - нужны усилия
- Но сильно проще, чем `exactly once`
- В широком классе ситуаций - де-факто `exactly once`

```kotlin
fun main() {
    runBlocking(Dispatchers.Default) {
        val actor = actor<String>() {
            for (data in channel) {
                println(data)
            }
        }
        actor.send("1234")
        actor.send("2345")
        actor.send("3456")
        actor.close()
    }
}
```

- Тип актора - тип сообщений, которые он принимает: строка - это для примера. В реальность там будет пачка `sealed`-классов с общим предком у каждого актора своя

- Надо в протоколе предусмотреть возможность передать `SendChannel`. Отправитель передает себя (`channel`). Получатель туда отправляет сообщения.
Можно организавать более сложные схемы взаимодействия

- Идентификация актора сводится к Java-объекту
- Актор может упасть
- В духе реактивного подхода он должен рестартовать
- Это можно сделать через супервизор
- Но это будет другой актор с другой идентичностью
