### Именованные параметры

Бывает так, что у функции есть несколько параметров одного типа, и их порядок неочевиден. Соглашений о порядке не сложилось. В этом случае легко перепутать

```kotlin
createUser("username", "id-123")

//            vs

createUser("id-123", "username")
```

В `Java` для конструкторов можно использовать `Builder`, но с методами проблема. Кроме того `Builder` нужно еще и писать

`Kotlin` позволяет использовать именованные параметры как в `Python`. В месте вызова функции сначала пишут неименованные параметры, затем именованные в произвольном порядка

```kotlin
fun test(x1: Int, x2: Int, x3: Int, x4: Int, x5: Int) {}

fun main() {
    test(1, 2, 3, x5=123, x4=12)
    test(x1=1, x2=2, 3 ,4, 5) // можно так. Сначала именованные параметры в том порядке, в котором они идут в функции, затем неименованные 
}
```
### Значения по умолчанию

Значения по умолчанию указываются в сигнатуре функции после название аргумента с типом через равно. Если для аргумента задано значение по умолчанию, то в месте вызова можно его не указывать

```kotlin
fun createUrl(protocol: String="https", host: String, port: Int=443, path: String="", query: String=""): URL {
    ...
}
```

### `vararg`

`vararg` - ключевое слово, которое можно указать перед аргументом, тогда этот аргумент при вызове может принять в себя произвольное число параметров, указанного типа после `:`.

Эти аргументы будут видны как обычный `Array`. Для примитивных типов это `IntArray` и ...

```kotlin
fun test(vararg xs: Int) { ... }
```

`vararg` может встречаться только 1 раз в определении. `vararg` можно сочетать с другими не `vararg` аргументами, но в этом случае если аргумент идет до `vararg`, то передаем его обычным способом, если аргумент после `vararg`, то его можно передать только как именованный параметр

```kotlin
fun test(vararg xs: Int, x0: Int, x1: Int) {
}

fun main() {
    test(1, 2, 3, 4, 5, x0 = 10, x1 = 100)
}
```

В точке вызова `vararg` жаден. Если идут значения его типа - заберет все. Если идет значение не его типа - ни себе, ни людям, и будет ошибка компиляции

Константы/переменные вставляются прямым перечислением. **Массив**(`Array<Type>`) можно вставить через `*`. Можно так несколько раз

```kotlin
fun test(vararg xs: Int, x0: Int, x1: Int) {
}

fun main() {
    val a = IntArray(3) { 0 }
    test(*a, *a, x0 = 0, x1 = 2)
}
```

### Конструкторы

У классов существует первичный конструктор

```kotlin
class C private constructor(val v: Int) { // Если не нужны модификаторы, 'constructor' можно опустить
    ...
}

class C1(val v: Int) {
    ...
}
```

В классе также можно объявить вторичные конструкторы. Синтаксис следующий

```kotlin
data class Point(val a: Int, val b: Int) {
    // вторичный конструктор
    constructor(p: Pair<Int, Int>): this(p.first, p.second) { // делегирование первичному конструктору обязательно при его наличии 
        ...
    }
}
```

Если хотим вызвать родительский конструктор, то используем супер. Родительский конструктор обязательно вызывать, либо через первичный, либо если его нет, то через обычные конструкторы

```kotlin
open data class Base(val x: Int)
data class Point: Base {
    // вторичный конструктор
    constructor(p: Pair<Int, Int>): super(p.first) { // вызов конструктора родителя 
        ...
    }
}
```

Цепочка делегирований конструкторов обязана привести к первичному. Это требование `Kotlin`. В теле вторичного конструктора - уже инициализированный объект

Потому что в этот момент над `this` не вызван конструктор суперкласса. А `JVM` к этому моменту относится особенно трепетно. Нельзя вызвать даже свои приватные методы, передать такой `this` компаньону - тоже

Первичный конструктор - максимально подробный. Если часто полные подробности не нужны, то используем параметры по умолчанию. А вторичные конструкторы - когда нужна другая сигнатура, не сводящаяся к первичному через параметры по умолчанию

Можем решить, что в первичном совсем мелкие детали. И приложению незачем о них знать - даже потенциально. Тогда первичный делаем приватным. И заводит несколько вторичных, которые будут декораторами приватного первичного. Максимально используем значения по умолчанию

Иногда перед вызовом первичного конструктора нужно как-то преобразовать аргумента, тогда в этом случае создание объекта можно делегировать компаньону

```kotlin
class Point(val x: Int, val y: Int){
    companion object {
        fun create(p: Pair<Int, Int>) : Point {
            val d = p.first + p.second
            val m = p.first * p.second
            return Point(m / d, m * d)
        }
    }
}
```

### Операторы

В `Kotlin` существует возможность определять операторы для классов. Для того, чтобы определить оператор используют ключевое слово `operator`. Операторы, которые можно определить ограниченно число

```
a + b                     a.plus(b)

a(i1, i2, ..., ik)        a.invoke(i1, i2, ..., ik)

a[i1, i2, ..., ik] = b    a.set(i1, i2, ..., ik, b)
```

```kotlin
data class Point(val x: Int, val y: Int) {
    operator fun plus(p: Point): Point {
        return Point(p.x + x, p.y + y)
    }
}

fun main() {
    val p1 = Point(1, 2)
    val p2 = Point(2, 1)
    println(p1 + p2)
}
```

### Наследование

Вместо `extends` - двоеточие. Вместо `implements` - тоже. `override` - ключевое слово

Перекрытие сигнатур - не проблема. Особенно если без реализации по умолчанию. И без значений параметров по умолчанию

```kotlin
interface Runnable {
    fun run() {
        println("Runnable")
    }
}

open class RunnableImpl1 : Runnable {
    override fun run() {
        println("RunnableImpl1")
    }
}

class RunnableImpl2 : RunnableImpl1(), Runnable {
    override fun run() {
        super<Runnable>.run() // нужно указать конкретный метод вызова
    }
}

fun main() {
    RunnableImpl2().run()
}
```